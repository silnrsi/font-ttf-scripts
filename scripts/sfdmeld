#!/usr/bin/perl

use IO::File;
use Encode::Unicode;
use Pod::Usage;
use Getopt::Std;
use Encode;
use Font::TTF::Scripts::AP;

getopts('hp');

unless ($ARGV[0] || $opt_h)
{
    pod2usage(1);
    exit;
}

if ($opt_h)
{
    pod2usage(-verbose => 2, -noperldoc => 1);
    exit;
}

my ($currchar, $font);
my %plabels = (
    'basechar' => '',
    'mark' => '_',
    'entry' => '>',
    'exit' => '<',
    'baselig' => ':',
    'basemark' => '+');
my %ptypes = join('', values %plabels);

$s = Font::TTF::Scripts::SFD->new(
    'AnchorClass2' => sub {
        my ($str) = @_;
        my (@a) = split(' ', $str);
        shift @a;
        while (@a) {
            my ($name) = shift @a;
            my ($subname) = shift @a;
            $name =~ s/^(['"])(.*?)\1/$2/o;   # "'
            $subname =~ s/^(['"])(.*?)\1/$2/o;   # "'
            $$font->{'anchor_classes'}{$name} = $subname;
        }
        return undef
    }, 'BeginChars' => sub {
        my ($str) = @_;
        my (@nums) = split(' ', $str);
        $$font->{'numg'} = $nums[1];
        return undef;
    }, 'StartChar' => sub {
        my ($name) = @_;
        $name =~ s/\s*$//o;

        $currchar = {'post' => $name, 'PSName' => $name};
        return $currchar;
    }, 'Encoding' => sub {
        my ($str) = @_;
        my (@vals) = split(' ', $str);
        $currchar->{'uni'} = [hex($vals[1])];
        $currchar->{'gnum'} = $vals[2];
        $$font->{'glyphs'}[$vals[2]] = $currchar;
        $$font->{'gnames'}{$currchar->{'post'}} = $vals[2];
        return undef;
    }, 'AnchorPoint' => sub {
        my ($str) = @_;
        my (@values) = split(' ', $str);
        my ($name) = $values[0];
        my ($pname);

        $name =~ s/^(['"])(.*?)\1/$2/o;   # "'
        $pname = $plabels{$values[3]} . $name;
        $currchar->{'points'}{$pname} = {'name' => $name,
            'x' => $values[1],
            'y' => $values[2],
            'type' => $values[3]};
        return undef;
    });

$struct = bless {}, "Font::TTF::Scripts::AP";
$design = bless {}, "Font::TTF::Scripts::AP";
$font = \$struct;
$s->parse_file($ARGV[0], $struct);
$font = \$design;
$s->parse_file($ARGV[1], $design);

$struct->make_names;
$design->make_names;
@map = $struct->align_glyphs($design);  # map from design -> struct
for ($i = 0; $i < @map; $i++)
{ $revmap[$map[$i]] = $i; } 

# Anchors position comes from design, but list from struct
for ($i = 0; $i < $design->{'numg'}; $i++)
{
    my ($char) = $design->{'glyphs'}[$i];
    my ($other) = $struct->{'glyphs'}[$map[$i]];
    my ($str);
    next unless (defined $other);

    foreach $p (keys %{$char->{'points'}})
    {
        next unless (defined $other->{'points'}{$p});
        my ($point) = $opt_p ? $other->{'points'}{$p} : $char->{'points'}{$p};
        $str .= "AnchorPoint: \"$point->{'name'}\" $point->{'x'} $point->{'y'} $point->{'type'} 0\n";
        $allpoints{$p} = 1;
    }

    foreach $p (keys %{$other->{'points'}})
    {
        next if (defined $char->{'points'}{$p});
        my ($point) = $other->{'points'}{$p};
        $str .= "AnchorPoint: \"$point->{'name'}\" $point->{'x'} $point->{'y'} $point->{'type'} 0\n";
        $allpoints{$p} = 1;
    }

    foreach $p (@{$char->{'commands'}{'AnchorPoint'}})
    { $char->{'lines'}[$p] = ''; }
    push (@{$char->{'lines'}}, $str);

    my ($res);
    foreach $p (qw(Substitution2 Ligature2 AlternateSubs2 MultipleSubs2))
    {
        foreach $i (@{$char->{'commands'}{$p}})
        { $char->{'lines'}[$i] = ''; }
        foreach $i (@{$other->{'commands'}{$p}})
        {
            my ($str) = $other->{'lines'}[$i];
            $str =~ s/^(\S+\s*\"[^"]*\")\s*//o;
            my ($pref) = $1;
            my (@gs) = split(' ', $str);
            $res .= ($res ? "\n" : "") . "$pref " . join(' ', 
                map {my($i)=$revmap[$struct->{'gnames'}{$_}]; $i ? $design->{'glyphs'}[$i]{'post'} : ""} @gs);
        }
    }
    foreach $p (qw(PairPos2 LCarets2 AltUni2 Kerns2 Position2))
    {
        foreach $i (@{$char->{'commands'}{$p}})
        { $char->{'lines'}[$i] = ''; }
        foreach $i (@{$other->{'commands'}{$p}})
        { $res .= $str; }
    }
    push (@{$char->{'lines'}}, "$res\n") if ($res);

    push (@{$char->{'lines'}}, $char->{'lines'}[$char->{'commands'}{'EndChar'}[-1]]);
    $char->{'lines'}[$char->{'commands'}{'EndChar'}[-1]] = '';
}

# copy lookups from struct -> design
foreach $t (qw(Lookup ChainSub2 ChainPos2 ContextSub2 ContextPos2 ReverseChain2))
{
    foreach $i (@{$design->{'commands'}{$t}})
    { $design->{'lines'}[$i] = ''; }
    $design->{'commands'}{$t} = [];
    next unless (defined $struct->{'commands'}{$t});
    foreach $i (@{$struct->{'commands'}{$t}})
    {
        my ($str) = $struct->{'lines'}[$i];
        push (@{$design->{'commands'}{$t}}, $#{$design->{'lines'}} - 1);
        $str =~ s/(Class|Coverage|String):\s+(.*?)\n/"$1: " . process_names($2, $struct, $design, \@revmap) . "\n"/oge;
        push (@{$design->{'lines'}}, $str);
    }
} 

foreach $t (@{$design->{'commands'}{'AnchorClass2'}})
{ $design->{'lines'}[$t] = ''; }
my ($str) = '';
foreach $t (@{$struct->{'commands'}{'AnchorClass2'}})
{ $str .= $struct->{'lines'}[$t]; }
push (@{$design->{'lines'}}, $str);


# now tidy up header so that BeginChars is at the end
push (@{$design->{'lines'}}, $design->{'lines'}[$design->{'commands'}{'BeginChars'}[0]]);
$design->{'lines'}[$design->{'commands'}{'BeginChars'}[0]] = '';

if (defined $ARGV[2])
{ $fh = IO::File->new("> $ARGV[2]") || die "Can't create $ARGV[2]"; }
else
{ $fh = STDOUT; }

$s->print_font($design, $fh);

if (defined $ARGV[2])
{ $fh->close(); }

sub process_names
{
    my ($str, $s, $d, $m) = @_;
    my (@n) = split(' ', $str);
    my ($res);

    shift (@n); # dump the length
    $res = join(" ", map {$i = $m->[$s->{'gnames'}{$_}]; $i ? $d->{'glyphs'}[$i]{'post'} : ""} @n);
    $res =~ s/\s{2,}//og;
    return length($res) . " $res";
}


package Font::TTF::Scripts::SFD;

use IO::File;

sub new
{
    my ($class, %info) = @_;
    my ($self) = {%info};
    return bless $self, ref $class || $class;
}

sub parse_file
{
    my ($self, $fname, $base) = @_;
    my ($fh);
    my ($command, $text);
    my %modes = (
        'TtTable' => 'EndTTInstrs',
        'TtInstrs' => 'EndTTInstrs',
        'Image' => 'EndImage',
        'TtfInstrs' => 'EndTtf',
        'ChainSub2' => 'EndFPST',
        'ChainPos2' => 'EndFPST',
        'ContextSub2' => 'EndFPST',
        'ContextPos2' => 'EndFPST',
        'ReverseChain2' => 'EndFPST',
        'ShortTable' => 'EndShort'
    );

    if (ref $fname)
    { $fh = $fname; }
    else
    { $fh = IO::File->new("< $fname") || die "Can't open $fname for reading"; }

    while (<$fh>)
    {
        my ($res);

        if ($_ =~ m/^[\s\d"]/o || $mode)
        {
            $text .= $_;
            if ($_ =~ m/^$mode/)
            { $mode = ''; }
            next;
        }
        elsif (defined $self->{$command})
        {
            my ($t) = $text;
            $t =~ s/^\s*//o;

            $res = &{$self->{$command}}($t);
            $base = $res if ($res);
        }
        if ($command)
        {
            my ($commstr) = $command;
            if ($text =~ m/^\s*$/o)
            { }
            elsif ($modes{$command})
            { $commstr .= ":"; }
            elsif ($text =~ m/\n.+\n/o)
            { }
            else
            { $commstr .= ":"; }
            push (@{$base->{'lines'}}, "$commstr$text");
            push (@{$base->{'commands'}{$command}}, scalar @{$base->{'lines'}} - 1);
            $command = '';
            $text = '';
        }

        if (s/^([^\s:]+)://o)
        {
            $command = $1;
            $text = $_ || "\n";
            $mode = $modes{$command};
        }
        else
        {
            $command = $_;
            $command =~ s/(\s*)$//o;
            $text = $1;
        }
    }
    if (defined $self->{$command})
    { &{$self->{$command}}($text); }
    push (@{$base->{'lines'}}, "$command$text");
    push (@{$base->{'commands'}{$command}}, scalar @{$base->{'lines'}});
}


sub print_font
{
    my ($self, $font, $fh) = @_;
    my ($g, $l);

    foreach $l (@{$font->{'lines'}})
    { $fh->print($l); }
    foreach $g (@{$font->{'glyphs'}})
    {
        foreach $l (@{$g->{'lines'}})
        { $fh->print($l); }
    }
}

__END__

=head1 TITLE

sfdmeld - merges sfd files

=head1 SYNOPSIS

  sfdaddap infile.sfd infile_ap.xml outfile.sfd

Reads a FontForge font file and extracts anchor point information into an XML
anchor point database.

=head1 OPTIONS

  -h            print manpage

=head1 DESCRIPTION

FontForge's has the concept of anchor points. This program extracts those and
any glyph comments into an XML anchor point database. See ttfbuilder -h for
documentation on this format.

=head1 SEE ALSO

ttfbuilder, volt2ap

=cut
